---
id: data-modelling
title: 'Data Modelling'
template: default.jade
customer: true
withTOC: true
---

In the following section, you will find all the necessary information to design your own data model and implement it under Pryv's conventions.

We describe two basic use cases : **data collection** to store and aggregate data from multiple data sources for a subject and **consent aggregation** of multiple subjects that granted permission to access their data.

### Data collection

Let's say you built an algorithm that computes allergen exposure based on geolocation data from your users and integrates it to their health profile.

All the different data sources store their data in a single account:
- **Smartwatch**: Collects in real-time the GPS position of the user (`position/wgs84`), which represents a high volume of data.
- **Allergen Exposure Mobile App**: Tracks the allergen exposure using the geolocation data from the smartwatch of the user.
- **Digital Tensiometer**: Used at home to daily monitor blood pressure (`blood pressure`) and added in the health profile of the user.

Here is a list of data generated by the applications and their corresponding Pryv types :

| Data              | Type               |
| :---------------- | :----------------- |
| Position          | `position/wgs84`   |
| Allergen exposure | `density/kg-m3`    |
| Blood pressure    | `blood-pressure/mmhg-bpm`|

One general advice is to use one stream or substream per device.
Given this situation, we would recommend a stream structure similar to the following:

![Example Streams Structure](/assets/images/data_model_allergens.png)

This stream structure has multiple benefits:
- it allows interoperability in the case of multiple data sources
- it provides enough context to the data and thus avoids ambiguities
- it enables granular accesses to streams

Let's imagine now that you want doctors to be able to provide feedback to users after consulting their health profile and allergen exposure. 
You can easily do so by adding a new stream `Doctor's feedback` in which the doctor will be communicating with his patient.

As multiple actors are involved in your process, you might need to restrict accesses to particular streams of the user's data.
For example, you can restrict the access to the stream `Position` to the Allergen Exposure App only and the access to the stream `Health Profile` to the doctor only, so that personal and sensitive data from the user is protected.

The streams structure and accesses over it would look like the following:

![Example Streams Structure](/assets/images/data_model_allergens_doctor.png)

This structure allows you a granular level of control of the accesses to the data. Different permissions can be defined for each stream and substream, therefore enabling you to share only necessary information with third-parties. Available levels of accesses (`read`, `manage`, `contribute`, `create-only`) are defined and explained [here](https://api.pryv.com/reference/#access). 

To implement this structure, you first need to create the root streams `smartwatch`, `allergen exposure app` and `health profile` and then the corresponding substreams, in which you will be able to insert the events. You can find out more on how to create streams [here](/guides/manipulate-streams).

Alternatively, you can also do a ["batch call"](http://api.pryv.com/reference/#call-batch) to create all the streams using a single API call. 

In our case :
```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "smartwatch",
      "name": "Smartwatch"
    }
  },
    {
    "method": "streams.create",
    "params": {
      "id": "allergen-exposure-app",
      "name": "Allergen Exposure App"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "pollen",
      "parentId": "allergen-exposure-app",
      "name": "Pollen"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "cereal-crops",
      "parentId": "allergen-exposure-app",
      "name": "Cereal crops"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "hazelnut-tree",
      "parentId": "allergen-exposure-app",
      "name": "Hazelnut tree"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "health-profile",
      "name": "Health Profile"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "digital-tensiometer",
      "parentId": "health-profile",
      "name": "Digital tensiometer"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "blood-pressure",
      "parentId": "digital-tensiometer",
      "name": "Blood pressure"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "weight",
      "parentId": "health-profile",
      "name": "Weight"
    }
  }
]
```

### Consent aggregation

Now, let's imagine that you want to store the accesses of multiple subjects that gave you their consent.
You will therefore need a "campaign" stream structure which allows you to store the accesses of these accounts in order to be able to retrieve data from these accounts.

![Example Campaign Structure](/assets/images/getting-started/campaign.png)

The "campaign" data structure described below will contain the following streams :

- The stream **"Campaign description"**, where you will store the requested permissions (the `streamId` you want to access e.g. `heartRate`, the level of permission e.g. "read"/"manage"/â€¦), the consent information, the app identifiers. 

```json
{
  "streamId": "campaign-123-description",
  "type": "campaign/sempryv",
  "name": "Campaign description",
  "parentId": "campaign-123",
  "content": {
    "requestedPermissions": {}, //...
    "consentText": "", //...
    "appId": "", //
    } 
}
```
- The stream **"Patient accesses"** that will contain the `username` and `token` properties for every subject that granted access to their data.
```json
{
      "streamId": "campaign-123-description",
      "type": "access/pryv",
      "name": "Patient accesses",
      "parentId": "campaign-123",
      "content": {
      "username": "subject01",
      "token": "ck0qmnwo40007a8ivbxn12zt7",
      } 
}
```

Similarly, you can create the streams one by one as explained [here](/guides/manipulate-streams) or all in one by doing a "batch call" : 

```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "campaign-123",
      "name": "Campaign name"
    }
  },
    {
    "method": "streams.create",
    "params": {
      "id": "campaign-123-description",
      "parentId": "campaign-123",
      "name": "Campaign description"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "campaign-123-patient-accesses",
      "parentId": "campaign-123",
      "name": "Patient accesses"
    }
  }
]
```
You can then add events to the different streams at once by doing an [events.create](/reference/#create-event) call, and store the campaign data in one stream, and the username and token of the subject in another stream:

```json
[
  {
    "method": "events.create",
    "params": {
    "time": 1385046854.282,
    "streamId": "campaign-123-description",
		"type": "campaign/pryv",
    "content": {
      "requestedPermissions": {}, //...
      "consentText": "", //...
      "appId": "", //
    }
    }
  },
  {
    "method": "events.create",
    "params": {
    "time": 1385046854.282,
    "streamId": "campaign-123-patient-accesses",
    "type": "access/pryv",
    "content": {
      "access": {
        "id": "ck0qmmwo40006a8ive8nkv9es",
        "username": "subject01",
        "token": "ck0qmmwo40007a8ivbxnl2zt7", 
        "urlEndpoint": "${PATIENT_USERNAME}.${PATIENT_DOMAIN}",
        "type": "shared",
        } 
      }
    }
  }
]
```

If the stream already exists, the error `item-already-exists` will be displayed (See [streams.create](/reference/#create-stream) specific errors for more information).