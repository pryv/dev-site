---
id: data-modelling
title: 'Data Modelling'
template: default.jade
customer: true
withTOC: true
---

In the following section, you will find all the necessary information to design your own data model and implement it under Pryv's conventions.

We describe two basic use cases : **data collection** to store and aggregate data from multiple data sources for a subject and **consent aggregation** of multiple subjects that granted permission to access their data.

### Data collection

Let's say you built an algorithm that computes allergen exposure based on geolocation data from your users and integrates it to their health profile.

All the different data sources store their data in the user's account:
- **Smartwatch**: Collects in real-time the GPS position of the user, which represents a high volume of data.
- **Allergen Exposure Mobile App**: Tracks the allergen exposure using the geolocation data from the smartwatch of the user.
- **Digital Tensiometer**: Used at home to daily monitor blood pressure and added in the health profile of the user.

Here is a list of data generated by the applications and their corresponding Pryv types :

| Data              | Type               |
| :---------------- | :----------------- |
| Position          | `position/wgs84`   |
| Allergen exposure | `density/kg-m3`    |
| Blood pressure    | `blood-pressure/mmhg-bpm`|

#### Streams structure

One general advice is to use one stream or substream per device.
Given this situation, we would recommend a stream structure similar to the following:

![Example Streams Structure](/assets/images/data_model_allergens.svg)

This stream structure has multiple benefits:
- Allows aggregation of data originating from different data sources
- Provides enough context to the data and thus avoids ambiguities
- Enables granular permissions to streams

Let's imagine now that you want doctors to provide feedback to users after consulting their health profile and allergen exposure. 
You can easily do so by adding a new stream `Doctor's feedback` in which the doctor will be communicating with his patient.

#### Accesses structure

As multiple actors are involved in your process, you might need to restrict accesses to particular streams of the user's data.
For example, you can restrict the access to the stream `Position` to the **Allergen Exposure App** only and the access to the stream `Health Profile` to the **Doctor** only, so that personal and sensitive data from the user is protected.

The streams structure and accesses over it would look like the following:

![Example Streams Structure](/assets/images/data_model_allergens_doctor.svg)

This structure allows you a granular level of control to accesses to the data. Different permissions can be defined for each stream and substream, therefore enabling you to share only necessary information with third-parties.  
For example, the access you will create (see [accesses.create](/reference/#create-access) call for more details) for the **Allergen Exposure App** will enable your app to `read` the geolocation data from the user and to `manage` the stream in which allergen exposure data will be added:

```json
{
  "access": {
    "id": "cka6h2b2t00065wpvubqj12xb",
    "token": "cka6h2b2t00075wpvgcuy4ocn",
    "type": "shared",
    "name": "For Allergen Exposure App",
    "permissions": [
      {
        "streamId": "position",
        "level": "read"
      },
      {
        "streamId": "allergen-exposure-app",
        "level": "manage"
      }
    ],
```

Available levels of permissions (`read`, `manage`, `contribute`, `create-only`) are defined and explained [here](/reference/#access).   

#### Implementation

A global overview of the streams and permissions structure of this use case is provided in this [Excel template](https://docs.google.com/spreadsheets/d/1UUb94rovSegFucEUtl9jcx4UcTAClfkKh9T2meVM5Zo/edit#gid=0). We advise you to build your own file based on this template in which you will describe your own data model depending on the use cases of your app/device.

To implement this structure, you first need to create the root streams `smartwatch`, `allergen exposure app` and `health profile` and then the corresponding substreams, in which you will be able to insert the events (see [streams.create](/reference/#create-stream) call for more details).

Alternatively, you can also do a ["batch call"](/reference/#call-batch) to create all the streams using a single API call. 

In our case :
```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "smartwatch",
      "name": "Smartwatch"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "position",
      "parentId": "smartwatch",
      "name": "Position"
    },
  }
    {
    "method": "streams.create",
    "params": {
      "id": "allergen-exposure-app",
      "name": "Allergen Exposure App"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "pollen",
      "parentId": "allergen-exposure-app",
      "name": "Pollen"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "cereal-crops",
      "parentId": "allergen-exposure-app",
      "name": "Cereal crops"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "hazelnut-tree",
      "parentId": "allergen-exposure-app",
      "name": "Hazelnut tree"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "health-profile",
      "name": "Health Profile"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "digital-tensiometer",
      "parentId": "health-profile",
      "name": "Digital tensiometer"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "blood-pressure",
      "parentId": "digital-tensiometer",
      "name": "Blood pressure"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "weight",
      "parentId": "health-profile",
      "name": "Weight"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "doctor-feedback",
      "name": "Doctor's feedback"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "comment",
      "parentId": "doctor-feedback",
      "name": "Comment"
    }
  }
]
```

### Consent aggregation

Let's imagine now a slightly different use case. You are conducting an Allergology Exposition research, in which you analyze the exposition of subjects to allergens by tracking their geolocation through your app.

#### Streams structure

You have been collecting consent from your app users to use their data and you need to store these accesses on Pryv.io. You will therefore need a "campaign" stream structure which allows you to store the accesses for your app.

![Example Campaign Structure](/assets/images/Campaign.svg)

The "campaign" data structure will contain the following streams:

- The stream **Campaign description**, in which you will store information about the authorization you are requesting. You can do a [streams.create](/reference/#create-stream) call with the following data:

```json
{
  "id": "campaign-description",
  "name": "Campaign description",
  "parentId": "allergology-exposition-campaign"
}
```
Its events will include the fields necessary to perform an [Auth request](/reference/#auth-request):

  - `requestingAppId`, your app's identifier that wishes to access data from the users
  - `requestedPermissions`, containing the streams your app wants to access and their associated level of permission
  - `clientData`, containing the consent information of your user

You can do an [events.create](/reference/#create-event) call containing this information:

```json
{
  "event": {
    "id": "ck9ckvwfo000vt4pvrudxci9b",
    "time": 1385046854.282,
    "streamIds": ["campaign-description]",
    "type": "campaign/auth-request",
    "content": {
      "requestingAppId": "allergen-exposure-app-id",
      "requestedPermissions": [
      {
          "streamId": "geolocation",
          "level": "read",
          "defaultName": "Geolocation"
      }],
      "clientData": {
        "app-web-auth:description": {
          "type": "note/txt",
          "content": "This is a consent message."
        }
      }
    }
  }
}
```
- The stream **Patient accesses** that will store the credentials in `pryvApiEndpoint` format (see [App guidelines](/guides/app-guidelines/)) for every subject that granted access to their data. You can do a [streams.create](/reference/#create-stream) call with the following data:

```json
{
  "id": "patient-accesses",
  "name": "Patient accesses",
  "parentId": "allergology-exposition-campaign"
}
```
The events of this stream will contain the credentials of every subject that granted access to their data, in particular the `pryvApiEndpoint` associated with their Pryv.io account.

You can do an [events.create](/reference/#create-event) call to store the credentials of "Subject 01" for example:
```json
{
  "event": {
    "id": "jk8ujvwfo000vt4vprfriwd5a",
    "time": 1385046854.285,
    "streamIds": ["patient-accesses"],
    "type": "access/pryv-api-endpoint",
    "content": "https://ck0qmnwo40007a8ivbxn12zt7@subject01.pryv.me/"
  }
}
```
#### Implementation

For this stream structure, you can create the streams as explained [here](/reference/#create-stream) or all in one by doing a "batch call" :
```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "allergology-exposition-campaign",
      "name": "Allergology Exposition Campaign"
    }
  },
    {
    "method": "streams.create",
    "params": {
      "id": "campaign-description",
      "parentId": "allergology-exposition-campaign",
      "name": "Campaign description"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "patient-accesses",
      "parentId": "allergology-exposition-campaign",
      "name": "Patient accesses"
    }
  }
]
```
