---
id: data-modelling
title: 'Data Modelling'
template: default.jade
customer: true
withTOC: true
---

In the following section, you will find all the necessary information to design your own model and implement it under Pryv's conventions.

We describe two fundamental use cases : **data collection** to store and aggregate data from multiple data sources for a subject and **consent aggregation** of multiple subjects that granted permission to access their data.

### Data collection

Let's take the case of an athlete who uses four applications to store data on Pryv.io. 
All four applications store their data in a single account:

- **Nutrition Mobile App**: Tracks the consumption of various types of food through pictures of meals.
- **Smartwatch A**: Collects the GPS position of the athlete during the training (`position/wgs84`), which represents a high volume of data.
- **Smartwatch B**: Linked to the same application but only used to monitor the `calories burned` and `heart rate` during the training.
- **Pulse Oximeter**: Used at home to check the health of the heart (`pulse rate`, `blood oxygenation / SpO2`)

Here is a list of data generated by the applications and their corresponding Pryv types :

| Data              | Type               |
| :---------------- | :----------------- |
| Heart rate        | `frequency/bpm`    |
| Blood oxygenation | `oxygen-rate/spo2` |
| Nutrition         | `picture/attached` |
| Physical activity | `position/wgs84`   |
| Physical activity | `energy/calories`  |

One general advice is to use one stream or substream per device.
Given this situation, we would recommend a stream structure similar to the following :

![Example Streams Structure](/assets/images/Data_modelling.svg)

This stream structure has multiple benefits:

- Provides enough context to the data and thus avoids ambiguities:
  - between food consumption (`calories ingested`) and physical activity (`calories burned`)
  - between consumption of different food (`foodA`, `foodB`)
- Allows interoperability in the case of multiple devices that:
  - measure the same type of data through different apps (`heartRate` from `pulseOximeterApp` and `smartwatchB`)
  - use the same app but measure different parameters (`smartwatchA` : `GPS position`, `smartwatchB` : `heartRate` and `calories burned`)

To implement it, you will first need to create the root streams `heart`, `blood`, etc and then the corresponding substreams, in which you will be able to insert the events. You can find out more on how to create streams [here](/guides/manipulate-streams).

Alternatively, you can also do a ["batch call"](http://api.pryv.com/reference/#call-batch) to create all the streams using a single API call. A batch call is recommended when you need to send a batch of API methods calls in one go (e.g. for syncing offline changes when resuming connectivity, for creating the streams structure, etc). In the property "method", you define the API method that you want to call and the parameters you wish to provide it.

In our case :
```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "heart",
      "name": "Heart"
    }
  },
    {
    "method": "streams.create",
    "params": {
      "id": "heartRate",
      "parentId": "heart",
      "name": "Heart Rate"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "pulseOximeterApp",
      "parentId": "heartRate",
      "name": "Pulse Oximeter Application"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "blood",
      "name": "Blood"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "bloodOxygenation",
      "parentId": "blood",
      "name": "Blood Oxygenation"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "physicalActivity",
      "name": "Physical Activity"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "smartwatchA",
      "parentId": "physicalActivity",
      "name": "Smart Watch A"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "smartwatchB",
      "parentId": "physicalActivity",
      "name": "Smart Watch B"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "foodConsumption",
      "name": "Food Consumption"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "foodA",
      "parentId": "foodConsumption",
      "name": "Food A"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "nutritionApp",
      "parentId": "foodA",
      "name": "Nutrition App"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "foodB",
      "parentId": "foodConsumption",
      "name": "Food B"
    }
  }
]
```

### Consent aggregation

Let's imagine now a different use case. You are conducting an Allergology Exposition research, in which you analyze the exposition of subjects to allergens by tracking their geolocation through your app.

You have been collecting consent from your app users to use their data and you need to store these accesses on Pryv.io in order to be able to retrieve data from their accounts.
You will therefore need a "campaign" stream structure which allows you to store the accesses for your app.

![Example Campaign Structure](/assets/images/Campaign.svg)

The "campaign" data structure will contain the following streams:

- The stream **Campaign description**, in which you will store information about the authorization you are requesting. 
You can do a [streams.create](https://api.pryv.com/reference/#create-stream) call with the following data:

```json
{
  "id": "campaign-description",
  "name": "Campaign description",
  "parentId": "allergology-exposition-campaign"
}
```

It will include the `requestingAppId` (your app's identifier that wishes to access data from the users), the `requestedPermissions` (containing the `streamId` your app wants to access and the level of permission) and the `clientData` (e.g. the consent information of your user).

You can do an [events.create](https://api.pryv.com/reference/#create-event) call containing this information:

```json
{
  "event": {
    "id": "ck9ckvwfo000vt4pvrudxci9b",
    "time": 1385046854.282,
    "streamIds": ["campaign-description]",
    "type": "campaign/auth-request",
    "content": {
        "requestingAppId": "test-app-id",
        "requestedPermissions": [
        {
            "streamIds": ["geolocation"],
            "level": "read",
            "defaultName": "Geolocation"
        }],
        "clientData": "", //...
    } 
  }
}
```
More information about the content of this event can be found in the [Auth request section](https://api.pryv.com/reference/#auth-request) of the API reference.

- The stream **Patient accesses** that will store the credentials (`username` and `token`) for every subject that granted access to their data. 
You can do a [streams.create](https://api.pryv.com/reference/#create-stream) call with the following data:

```json
{
  "id": "patient-accesses",
  "name": "Patient accesses",
  "parentId": "allergology-exposition-campaign"
}
```

The events of this stream will contain the credentials of every subject that granted access to their data, in particular the `username` and the `token` associated with their Pryv.io account.

You can do an [events.create](https://api.pryv.com/reference/#create-event) call to store the credentials of "Subject 01" for example:

```json
{
  "event": {
    "id": "jk8ujvwfo000vt4vprfriwd5a",
    "time": 1385046854.285,
    "streamIds": ["patient-accesses"],
    "type": "access/pryv",
    "content": {
      "username": "subject01",
      "token": "ck0qmnwo40007a8ivbxn12zt7",
      } 
  }
}
```


For this stream structure, you can create the streams one by one as explained [here](/guides/manipulate-streams) or all in one by doing a "batch call" : 

```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "allergology-exposition-campaign",
      "name": "Allergology Exposition Campaign"
    }
  },
    {
    "method": "streams.create",
    "params": {
      "id": "campaign-description",
      "parentId": "allergology-exposition-campaign",
      "name": "Campaign description"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "patient-accesses",
      "parentId": "allergology-exposition-campaign",
      "name": "Patient accesses"
    }
  }
]
```
You can then add events to the different streams at once by doing an [events.create](/reference/#create-event) call, and store the campaign data in one stream, and the username and token of the subject in another stream:

```json
[
  {
    "method": "events.create",
    "params": {
      "time": 1385046854.282,
      "streamIds": ["campaign-description"],
      "type": "campaign/auth-request",
      "content": {
        "requestingAppId": "", //...
        "requestedPermissions": {}, //...
        "clientData": "", //
      }
    }
  },
  {
    "method": "events.create",
    "params": {
      "time": 1385046854.283,
      "streamIds": ["patient-accesses"],
      "type": "access/pryv",
      "content": {
          "username": "subject01",
          "token": "ck0qmnwo40007a8ivbxn12zt7",
        }
      }
    }
]
```

If the stream already exists, the error `item-already-exists` will be displayed (See [streams.create](/reference/#create-stream) specific errors for more information).