---
id: data-modelling
title: 'Data Modelling'
template: default.jade
customer: true
withTOC: true
---

In the following section, you will find all the necessary information to design your own model and implement it under Pryv's conventions.

We describe two fundamental use cases : **data collection** to store and aggregate data from multiple data sources for a subject and **consent aggregation** of multiple subjects that granted permission to access their data.

### Data collection

Let's take the case of an athlete who uses four applications to store data on Pryv.io. 
All four applications store their data in a single account:

- **Nutrition Mobile App**: Tracks the consumption of various types of food through pictures of meals.
- **Smartwatch A**: Collects the GPS position of the athlete during the training (`position/wgs84`), which represents a high volume of data.
- **Smartwatch B**: Linked to the same application but only used to monitor the `calories burned` and `heart rate` during the training.
- **Pulse Oximeter**: Used at home to check the health of the heart (`pulse rate`, `blood oxygenation / SpO2`)

Here is a list of data generated by the applications and their corresponding Pryv types :

| Data              | Type               |
| :---------------- | :----------------- |
| Heart rate        | `frequency/bpm`    |
| Blood oxygenation | `oxygen-rate/spo2` |
| Nutrition         | `picture/attached` |
| Physical activity | `position/wgs84`   |
| Physical activity | `energy/calories`  |

One general advice is to use one stream or substream per device.
Given this situation, we would recommend a stream structure similar to the following :

![Example Streams Structure](/assets/images/getting-started/streams_structure_v2.png)

This stream structure has multiple benefits:

- Provides enough context to the data and thus avoids ambiguities:
  - between food consumption (`calories ingested`) and physical activity (`calories burned`)
  - between consumption of different food (`foodA`, `foodB`)
- Allows interoperability in the case of multiple devices that:
  - measure the same type of data through different apps (`heartRate` from `pulseOximeterApp` and `smartwatchB`)
  - use the same app but measure different parameters (`smartwatchA` : `GPS position`, `smartwatchB` : `heartRate` and `calories burned`)

To implement it, you will first need to create the root streams `heart`, `blood`, etc and then the corresponding substreams, in which you will be able to insert the events. You can find out more on how to create streams [here](/guides/manipulate-streams).

Alternatively, you can also do a ["batch call"](http://api.pryv.com/reference/#call-batch) to create all the streams using a single API call. A batch call is recommended when you need to send a batch of API methods calls in one go (e.g. for syncing offline changes when resuming connectivity, for creating the streams structure, etc). In the property "method", you define the API method that you want to call and the parameters you wish to provide it.

In our case :
```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "heart",
      "name": "Heart"
    }
  },
    {
    "method": "streams.create",
    "params": {
      "id": "heartRate",
      "parentId": "heart",
      "name": "Heart Rate"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "pulseOximeterApp",
      "parentId": "heartRate",
      "name": "Pulse Oximeter Application"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "smartwatchA",
      "parentId": "pulseOximeterApp",
      "name": "Smart Watch A"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "blood",
      "name": "Blood"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "bloodOxygenation",
      "parentId": "blood",
      "name": "Blood Oxygenation"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "pulseOximeterApp",
      "parentId": "bloodOxygenation",
      "name": "Pulse Oximeter Application"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "physicalActivity",
      "name": "Physical Activity"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "smartwatchA",
      "parentId": "physicalActivity",
      "name": "Smart Watch A"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "smartwatchB",
      "parentId": "physicalActivity",
      "name": "Smart Watch B"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "foodConsumption",
      "name": "Food Consumption"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "foodA",
      "parentId": "foodConsumption",
      "name": "Food A"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "nutritionApp",
      "parentId": "foodA",
      "name": "Nutrition App"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "foodB",
      "parentId": "foodConsumption",
      "name": "Food B"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "nutritionApp",
      "parentId": "foodB",
      "name": "Nutrition App"
    }
  }
]
```

### Consent aggregation

Now, let's imagine that you want to store the accesses of multiple subjects that gave you their consent.
You will therefore need a "campaign" stream structure which allows you to store the accesses of these accounts in order to be able to retrieve data from these accounts.

![Example Campaign Structure](/assets/images/getting-started/campaign.png)

The "campaign" data structure described below will contain the following streams :

- The stream **"Campaign description"**, where you will store the requested permissions (the `streamId` you want to access e.g. `heartRate`, the level of permission e.g. "read"/"manage"/â€¦), the consent information, the app identifiers. 

```json
{
  "streamId": "campaign-123-description",
  "type": "campaign/sempryv",
  "name": "Campaign description",
  "parentId": "campaign-123",
  "content": {
    "requestedPermissions": {}, //...
    "consentText": "", //...
    "appId": "", //
    } 
}
```
- The stream **"Patient accesses"** that will contain the `username` and `token` properties for every subject that granted access to their data.
```json
{
      "streamId": "campaign-123-description",
      "type": "access/pryv",
      "name": "Patient accesses",
      "parentId": "campaign-123",
      "content": {
      "username": "subject01",
      "token": "ck0qmnwo40007a8ivbxn12zt7",
      } 
}
```

Similarly, you can create the streams one by one as explained [here](/guides/manipulate-streams) or all in one by doing a "batch call" : 

```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "campaign-123",
      "name": "Campaign name"
    }
  },
    {
    "method": "streams.create",
    "params": {
      "id": "campaign-123-description",
      "parentId": "campaign-123",
      "name": "Campaign description"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "campaign-123-patient-accesses",
      "parentId": "campaign-123",
      "name": "Patient accesses"
    }
  }
]
```
You can then add events to the different streams at once by doing an [events.create](/reference/#create-event) call, and store the campaign data in one stream, and the username and token of the subject in another stream:

```json
[
  {
    "method": "events.create",
    "params": {
    "time": 1385046854.282,
    "streamId": "campaign-123-description",
		"type": "campaign/pryv",
    "content": {
      "requestedPermissions": {}, //...
      "consentText": "", //...
      "appId": "", //
    }
    }
  },
  {
    "method": "events.create",
    "params": {
    "time": 1385046854.282,
    "streamId": "campaign-123-patient-accesses",
    "type": "access/pryv",
    "content": {
      "access": {
        "id": "ck0qmmwo40006a8ive8nkv9es",
        "username": "subject01",
        "token": "ck0qmmwo40007a8ivbxnl2zt7", 
        "urlEndpoint": "${PATIENT_USERNAME}.${PATIENT_DOMAIN}",
        "type": "shared",
        } 
      }
    }
  }
]
```

If the stream already exists, the error `item-already-exists` will be displayed (See [streams.create](https://api.pryv.com/reference/#create-stream) specific errors for more information).