---
id: data-modelling
title: 'Data Modelling'
template: default.jade
customer: true
withTOC: true
---

In the following section, you will find all the necessary information to design your own data model.

The general introduction describes Pryv.io data modelling conventions to help you understand how you should build your own data model. Then we provide you with a broad range of use cases that you can encounter while building your data model.

## Table of contents

1. [Introduction](#introduction)
2. [Use cases](#use-cases)
  1. [Declaring the stream structure](#declaring-the-stream-structure)
  2. [Storing patient accesses](#storing-patient-accesses)
  3. [Referencing events](#referencing-events) 
  4. [Storing an event in multiple streams](#storing-an-event-in-multiple-streams)
  5. [Storing Profile/Account information](#storing-profile-account-information) 
  6. [Avoiding event types multiplication](#avoiding-event-types-multiplication)
  7. [Storing technical data from devices](#storing-technical-data-from-devices) 
  8. [Handling multiple devices](#handling-multiple-devices)
  9. [Defining a custom event type](#defining-a-custom-event-type)
  10. [Performing an access delegation](#performing-an-access-delegation)
  11. [Defining accesses to the streams](#defining-accesses-to-the-streams)
  

## Introduction

Data in Pryv is organized in "streams" and "events":
- **Streams** are the main way of encoding context for events. They act as folders in which data is stored ("Health", "Geolocation", etc), and follow a tree structure.
- **Events** are the primary unit of content in Pryv.io. They correspond to files that are inserted in corresponding folders. An event is a timestamped piece of typed data (e.g `note/txt`), and belongs to one or multiple streams. It can either have a type from the [list of standard event types](https://api.pryv.com/event-types/) or a custom type that can be created for the intended use case.

Let's take the example of a Pryv.io user who wants to keep track of his health metrics and his physical activity using a smartwatch. A simple and intuitive way to model his data would be to use two streams, "Health Profile" and "Smartwatch":
- "**Health Profile**" corresponds to the health metrics of the user, with for example, the sub-streams "**Height**" and "**Weight**" in which the height and weight measurements are respectively added (events of type `length/cm` and `mass/kg` respectively).
- "**Smartwatch**" contains the collected data from the smartwatch, in particular the geolocation of the user - sub-stream "**Position**" - and the "**Energy**", that can be either the "**Energy-intake**" or the "**Energy-burnt**" (events of type `energy/cal`).

The stream structure of this data model can be visually represented as below:

![Simplified Streams Structure](/assets/images/data_model_simplified.svg)

This stream structure allows you to:

- aggregate data from different data sources
- provide enough context to the data
- control on a granular level accesses to the data

Different permissions can be defined for each stream and substream, therefore enabling to share only necessary information with third-parties (apps, doctors, family, etc). If multiple actors are involved in the process, this allows to precisely control the access level to the different streams. 

![Access Structure](/assets/images/data_model_access.svg)

In the example above, access to particular streams of data can be restricted:

- the **Smartwatch app** has a `manage` access on the streams **Position** and **Energy**, and a `read` access on the streams **Height** and **Weight**
- the **Dietetician** has a `read` access on the stream **Energy**

Available levels of permissions (read, manage, contribute, create-only) are defined and explained [here](https://api.pryv.com/reference/#access).

## Use cases

### Handling multiple devices

Let's imagine that you are storing data from multiple devices/data sources in a Pryv.io user's account:
- a **Smartwatch** that collects the heart rate of the user during his sleep
- a **Sleep Control Mobile App** that controls the sleep quality using data from the smartwatch
- a **Glucose Monitoring Device** thats is used at home to daily monitor glucose levels and added in the health profile of the user

One general advice is to use one stream or substream per device. Each event can be stored across one or multiple streams: this enables you to save an event, e.g a `sleep/analysis` event, in both streams **Sleep Control Mobile App** and **Health Profile** and to contextualize the event.

Given this situation, we would recommend a stream structure similar to the following:


```bash
├── Stream 1
│   ├── subStream 2
│   │   ├── event ?
│   ├── favicon.ico
│   ├── images
│   ├── index.html
│   ├── js
│   │   ├── **/*.js
│   └── partials/template
└── Stream 3
```


Here is a list of data generated by the applications and their corresponding [Pryv types](https://api.pryv.com/event-types/) :

| Data              | Type               |
| :---------------- | :----------------- |
| Glucose monitor   | `density/mmol-l`   |
| Sleep analysis    | `sleep/analysis`   |
| Blood pressure    | `blood-pressure/mmhg-bpm`|








Let's say you built an algorithm that computes allergen exposure based on geolocation data from your users and integrates it to their health profile.

All the different data sources store their data in the user's account:
- **Smartwatch**: Collects in real-time the GPS position of the user, which represents a high volume of data.
- **Allergen Exposure Mobile App**: Tracks the allergen exposure using the geolocation data from the smartwatch of the user.
- **Digital Tensiometer**: Used at home to daily monitor blood pressure and added in the health profile of the user.

Here is a list of data generated by the applications and their corresponding Pryv types :

| Data              | Type               |
| :---------------- | :----------------- |
| Position          | `position/wgs84`   |
| Allergen exposure | `density/kg-m3`    |
| Blood pressure    | `blood-pressure/mmhg-bpm`|

- Stream structure

One general advice is to use one stream or substream per device.
Given this situation, we would recommend a stream structure similar to the following:

![Example Streams Structure](/assets/images/data_model_allergens.svg)

This stream structure has multiple benefits:
- Allows aggregation of data originating from different data sources
- Provides enough context to the data and thus avoids ambiguities
- Enables granular permissions to streams

Let's imagine now that you want doctors to provide feedback to users after consulting their health profile and allergen exposure. 
You can easily do so by adding a new stream `Doctor's feedback` in which the doctor will be communicating with his patient.

- Access structure

As multiple actors are involved in your process, you might need to restrict accesses to particular streams of the user's data.
For example, you can restrict the access to the stream `Position` to the **Allergen Exposure App** only and the access to the stream `Health Profile` to the **Doctor** only, so that personal and sensitive data from the user is protected.

The streams structure and accesses over it would look like the following:

![Example Streams Structure](/assets/images/data_model_allergens_doctor.svg)

This structure allows you a granular level of control to accesses to the data. Different permissions can be defined for each stream and substream, therefore enabling you to share only necessary information with third-parties.  
For example, the access you will create (see [accesses.create](/reference/#create-access) call for more details) for the **Allergen Exposure App** will enable your app to `read` the geolocation data from the user and to `manage` the stream in which allergen exposure data will be added:

```json
{
  "access": {
    "id": "cka6h2b2t00065wpvubqj12xb",
    "token": "cka6h2b2t00075wpvgcuy4ocn",
    "type": "shared",
    "name": "For Allergen Exposure App",
    "permissions": [
      {
        "streamId": "position",
        "level": "read"
      },
      {
        "streamId": "allergen-exposure-app",
        "level": "manage"
      }
    ],
```

Available levels of permissions (`read`, `manage`, `contribute`, `create-only`) are defined and explained [here](/reference/#access).   

- Implementation

A global overview of the streams and permissions structure of this use case is provided in this [Excel template](https://docs.google.com/spreadsheets/d/1UUb94rovSegFucEUtl9jcx4UcTAClfkKh9T2meVM5Zo/edit#gid=0). We advise you to build your own file based on this template in which you will describe your own data model depending on the use cases of your app/device.

To implement this structure, you first need to create the root streams `smartwatch`, `allergen exposure app` and `health profile` and then the corresponding substreams, in which you will be able to insert the events (see [streams.create](/reference/#create-stream) call for more details).

Alternatively, you can also do a ["batch call"](/reference/#call-batch) to create all the streams using a single API call. 

In our case :
```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "smartwatch",
      "name": "Smartwatch"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "position",
      "parentId": "smartwatch",
      "name": "Position"
    },
  }
    {
    "method": "streams.create",
    "params": {
      "id": "allergen-exposure-app",
      "name": "Allergen Exposure App"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "pollen",
      "parentId": "allergen-exposure-app",
      "name": "Pollen"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "cereal-crops",
      "parentId": "allergen-exposure-app",
      "name": "Cereal crops"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "hazelnut-tree",
      "parentId": "allergen-exposure-app",
      "name": "Hazelnut tree"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "health-profile",
      "name": "Health Profile"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "digital-tensiometer",
      "parentId": "health-profile",
      "name": "Digital tensiometer"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "blood-pressure",
      "parentId": "digital-tensiometer",
      "name": "Blood pressure"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "weight",
      "parentId": "health-profile",
      "name": "Weight"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "doctor-feedback",
      "name": "Doctor's feedback"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "comment",
      "parentId": "doctor-feedback",
      "name": "Comment"
    }
  }
]
```

## Storing patient accesses

Let's imagine now a slightly different use case. You are conducting an Allergology Exposition research, in which you analyze the exposition of subjects to allergens by tracking their geolocation through your app.

- Stream structure

You have been collecting consent from your app users to use their data and you need to store these accesses on Pryv.io. You will therefore need a "campaign" stream structure which allows you to store the accesses for your app.

![Example Campaign Structure](/assets/images/Campaign.svg)

The "campaign" data structure will contain the following streams:

- The stream **Campaign description**, in which you will store information about the authorization you are requesting. You can do a [streams.create](/reference/#create-stream) call with the following data:

```json
{
  "id": "campaign-description",
  "name": "Campaign description",
  "parentId": "allergology-exposition-campaign"
}
```
Its events will include the fields necessary to perform an [Auth request](/reference/#auth-request):

  - `requestingAppId`, your app's identifier that wishes to access data from the users
  - `requestedPermissions`, containing the streams your app wants to access and their associated level of permission
  - `clientData`, containing the consent information of your user

You can do an [events.create](/reference/#create-event) call containing this information:

```json
{
  "event": {
    "id": "ck9ckvwfo000vt4pvrudxci9b",
    "time": 1385046854.282,
    "streamIds": ["campaign-description]",
    "type": "campaign/auth-request",
    "content": {
      "requestingAppId": "allergen-exposure-app-id",
      "requestedPermissions": [
      {
          "streamId": "geolocation",
          "level": "read",
          "defaultName": "Geolocation"
      }],
      "clientData": {
        "app-web-auth:description": {
          "type": "note/txt",
          "content": "This is a consent message."
        }
      }
    }
  }
}
```
- The stream **Patient accesses** that will store the credentials in `pryvApiEndpoint` format (see [App guidelines](/guides/app-guidelines/)) for every subject that granted access to their data. You can do a [streams.create](/reference/#create-stream) call with the following data:

```json
{
  "id": "patient-accesses",
  "name": "Patient accesses",
  "parentId": "allergology-exposition-campaign"
}
```
The events of this stream will contain the credentials of every subject that granted access to their data, in particular the `pryvApiEndpoint` associated with their Pryv.io account.

You can do an [events.create](/reference/#create-event) call to store the credentials of "Subject 01" for example:
```json
{
  "event": {
    "id": "jk8ujvwfo000vt4vprfriwd5a",
    "time": 1385046854.285,
    "streamIds": ["patient-accesses"],
    "type": "access/pryv-api-endpoint",
    "content": "https://ck0qmnwo40007a8ivbxn12zt7@subject01.pryv.me/"
  }
}
```
- Implementation

For this stream structure, you can create the streams as explained [here](/reference/#create-stream) or all in one by doing a "batch call" :
```json
[
  {
    "method": "streams.create",
    "params": {
      "id": "allergology-exposition-campaign",
      "name": "Allergology Exposition Campaign"
    }
  },
    {
    "method": "streams.create",
    "params": {
      "id": "campaign-description",
      "parentId": "allergology-exposition-campaign",
      "name": "Campaign description"
    }
  },
  {
    "method": "streams.create",
    "params": {
      "id": "patient-accesses",
      "parentId": "allergology-exposition-campaign",
      "name": "Patient accesses"
    }
  }
]
```
