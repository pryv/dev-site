---
name: 'event-types'
title: 'Event types'
layout: 'default'
withExamples: false
withTOC: true
---

- var sourceFile = 'event-types/hierarchical-staging.json'
- var flatFile = 'event-types/flat-staging.json'
- var extrasFile = 'event-types/extras.json'

-// load JSON files

- var content = require('files/' + sourceFile)
- var classes = content.classes;

- var extras = require('files/' + extrasFile) // TODO: use this?

-// extract numerical types (classes)

- var numericalClasses = {}
- var classNames = Object.keys(classes);
each className in classNames
  - var classDef = classes[className]
  - var numberOnly = true

  each formatName in Object.keys(classDef.formats)
    - var formatDef = classDef.formats[formatName]
    if formatDef.type !== 'number'
      - numberOnly = false
      - break

  if numberOnly
    - numericalClasses[className] = classDef
    - delete classes[className]


.version Directory version: <strong>#{content.version}</strong>

section#about
  h1 Event types
  :markdown
    This is the reference for the standard event types we recommend and handle (or will
    handle) in the Pryv apps. You are free to use any type in your app, but for the sake of
    interoperability we heavily recommend that you stick to the standard types listed here,
    and <a href="mailto:developers@pryv.com">get in touch with us</a> to complete the
    directory if you don't find what you need.

    ## Event type?

    An event's type is defined by its `type` property that indicates how to handle its `content` (if any).
    The type itself is specified as `{class}/{format}`, lowercase (e.g. `note/html`). Rationale:

    - The class specifies the "nature" or "kind" of data represented by the event.
      Events of the same class are assumed to be comparable and convertible,
      and will likely be displayed similarly.
    - The format specifies how the data is structured. For example, a
      basic note may just be a single string value, while an rich-text note could be a more complex
      object structure.

    ## Format specification

    For each of the types described below, the event content's structure is specified using
    JSON-schema (see the
    [JSON-schema specification](http://tools.ietf.org/html/draft-zyp-json-schema-03#page-8)).
    Notes:

    - A "null" content type means that the event has no `content` property (usually because event
      core properties are sufficient).
    - Any content type other than "null" implies that the event must have a `content` property of the
      specified JSON-schema type.
    - If the content is an object, its (sub-)properties are assumed to be optional unless
      otherwise specified by JSON-schema's "required" field.

    ## JSON file

    This directory is available as a JSON file for automated processing:

    - [Hierarchical structure](!{sourceFile}): `classes['{class}'].formats['{format}']`
    - [Flat structure](!{flatFile}): `types['{class}/{format}']`

    ## Submitting new types to the directory

    This directory is constantly evolving to match the needs of Pryv apps; if you'd like it
    to include other types, <a href="mailto:developers@pryv.com">send us your proposal</a>.


section#directory
  h1 Directory

  h2 Complex types

  mixin renderProperties(obj, isPropertyList)
    ul
      each key in Object.keys(obj)
        - var value = obj[key]
        li
          - var keyElt = isPropertyList ? 'code' : 'strong'
          | <!{keyElt}>!{key}</!{keyElt}>:!{' '}
          case typeof value
            when 'object'
              mixin renderProperties(value, key === 'properties')
            when 'array'
              | !{value.join(', ')}
            default
              | !{value}

  for className in Object.keys(classes)
    - var classDef = classes[className]
    h3 !{className.charAt(0).toUpperCase() + className.slice(1)}
    .description !{classDef.description}
    - var headers = []
    for formatName in Object.keys(classDef.formats)
      - var formatDef = classDef.formats[formatName]
        for formatField in Object.keys(formatDef)
          - headers.push(formatField)
    - headers = headers.filter(function(el,i,a){if(i==a.indexOf(el))return 1;return 0})
    - headers.sort(function(a,b){if(a==='description')return -1;if(a==='type')return -1;return a.localeCompare(b);})
    table.table
      thead
        tr
          -// format id column.
          th type
          each header in headers
            if header !== 'properties' && header !== 'example'
              -// other custom columns.
              th= header
      tbody
        for formatName in Object.keys(classDef.formats)
          - var formatDef = classDef.formats[formatName]
          - var properties = formatDef['properties']
          - var example = formatDef['example']
          - var type = formatDef['type']
          - var rowSpan = 1 + (properties ? 1 : 0) + (example ? 1 : 0)
          - var colSpan = headers.length - (properties ? 1 : 0) - (example ? 1 : 0)

          tr
            -// format id column.
            td(rowspan=rowSpan) <code>!{className}/!{formatName}</code>
            each header in headers
              -// other custom columns.
              - var value = formatDef[header]
              if header !== 'properties' && header !== 'example'
                if header === 'pattern' && value
                  td <code>!{value}</code>
                else
                  td !{value}
            if properties
              tr
                td(colspan=colSpan)
                  strong properties
                  mixin renderProperties(properties, true)
            if example
              tr
                td(colspan=colSpan)
                  strong example
                  pre.example
                    code= JSON.stringify(example, null, 2)

  h2 Numerical types

  for className in Object.keys(numericalClasses)
    - var classDef = numericalClasses[className]
    h3 !{className.charAt(0).toUpperCase() + className.slice(1)}
    .description !{classDef.description}

    table.table
      thead
        tr
          -// format id column.
          th type
          th title

      tbody
        for formatName in Object.keys(classDef.formats)
          - var formatDef = classDef.formats[formatName]
          - var formatDescription = formatDef.description
          tr
            -// format id column.
            td <code>!{className}/!{formatName}</code>
            td !{formatDescription}
